### 시간복잡도

시간복잡도는 입력 데이터에 대한 실행시간에 대한 것이다. 보통 최악의 경우를 상정하는 빅오표기법을 사용한다. <br/>

빅오표기법에서 상수는 버린다. <br/>
길이가 N 인 배열의 절반만 순회하먄 된다면 시간복잡도는 O(N/2) 이지만 상수는 버리고 O(N) 으로 계산한다. <br/>
마찬가지로 길이가 N 인 배열을 두 번 순회해야한다면 O(2N) 이 아닌 O(N) 이 된다. `O(N) = O(2N)` <br/>

상수가 아닌 이차원베열을 순회하는 O(N*M) 같은 경우에는 시간복잡도로 계산한다. <br/>

```
이진탐색 = O(log N)
선형탐색 = O(N)
정렬 = O(N log N)
조합 = O(2^N)
순열 = O(N!)
```

#### 시간복잡도를 줄이는 시도
배열에서 특정 원소를 찾는 경우 일반적으로 배열을 순회하는 경우 `O(N)` 이 소요된다. <br/>
만약 문제에 정렬된 배열이라는 조건이 붙는다면 `이진탐색` 을 사용한다면 시간복잡도를 `O(log N)` 으로 줄일 수 있다. <br/>

배열에서 중복된 원소를 제거하려는 경우 모든 원소를 순회하는 2중 for 문을 사용한다면 `O(N^2)` 의 시간복잡도를 갖는다.<br/>
만약 `set` 자료구조를 사용한다면 중복을 제거하는데 `O(N)` 의 시간복잡도만으로 해결할 수 있게 된다.


#### 두 개 알고리즘 (두 개 반복문이 사용된다면?)

```
for (int a: arr) {
	...
}

for (int b: arr) {
	for (int c: arr) {
		...
	}
}
```

시간복잡도는 `O(N^2 + N)` 이 되지만 빅오표기법 계산시 차수가 가장 큰 항만을 취하면 되기 때문에 `O(N^2)` 로 계산한다. <br/>

